/* tslint:disable */
/* eslint-disable */
/**
 * 
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';


/**
 * 
 * @export
 * @interface AuthIn
 */
export interface AuthIn {
    /**
     * 
     * @type {string}
     * @memberof AuthIn
     */
    'code': string;
}
/**
 * 
 * @export
 * @interface DepartmentRead
 */
export interface DepartmentRead {
    /**
     * 
     * @type {number}
     * @memberof DepartmentRead
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof DepartmentRead
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface PaginatedDepartmentReadList
 */
export interface PaginatedDepartmentReadList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedDepartmentReadList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedDepartmentReadList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedDepartmentReadList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<DepartmentRead>}
     * @memberof PaginatedDepartmentReadList
     */
    'results'?: Array<DepartmentRead>;
}
/**
 * 
 * @export
 * @interface DivisionRead
 */
export interface DivisionRead {
    /**
     * 
     * @type {number}
     * @memberof DivisionRead
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof DivisionRead
     */
    'name': string;
}

/**
 * 
 * @export
 * @interface PaginatedDivisionReadList
 */
export interface PaginatedDivisionReadList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedDivisionReadList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedDivisionReadList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedDivisionReadList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<DivisionRead>}
     * @memberof PaginatedDivisionReadList
     */
    'results'?: Array<DivisionRead>;
}
/**
 * 
 * @export
 * @interface PaginatedTypeOfRequestReadList
 */
export interface PaginatedTypeOfRequestReadList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedTypeOfRequestReadList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedTypeOfRequestReadList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedTypeOfRequestReadList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<TypeOfRequestRead>}
     * @memberof PaginatedTypeOfRequestReadList
     */
    'results'?: Array<TypeOfRequestRead>;
}
/**
 * 
 * @export
 * @interface RequestCreate
 */
export interface RequestCreate {
    /**
     * 
     * @type {string}
     * @memberof RequestCreate
     */
    'contact_name': string;
    /**
     * 
     * @type {string}
     * @memberof RequestCreate
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof RequestCreate
     */
    'phone'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RequestCreate
     */
    'date': string;
    /**
     * 
     * @type {number}
     * @memberof RequestCreate
     */
    'division'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof RequestCreate
     */
    'department': number | null;
    /**
     * 
     * @type {number}
     * @memberof RequestCreate
     */
    'typeOfRequest': number | null;
    /**
     * 
     * @type {number}
     * @memberof RequestCreate
     */
    'type'?: number | null;
}
/**
 * 
 * @export
 * @interface TypeOfRequestRead
 */
export interface TypeOfRequestRead {
    /**
     * 
     * @type {number}
     * @memberof TypeOfRequestRead
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof TypeOfRequestRead
     */
    'name': string;
}

/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {AuthIn} authIn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authCreate: async (authIn: AuthIn, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authIn' is not null or undefined
            assertParamExists('authCreate', 'authIn', authIn)
            const localVarPath = `/api/auth/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authIn, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {AuthIn} authIn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authCreate(authIn: AuthIn, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, baseUrl?: string) => AxiosPromise<AuthIn>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authCreate(authIn, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerbaseUrl = operationServerMap['AuthApi.authCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, baseUrl) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerbaseUrl || baseUrl);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, baseUrl?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * 
         * @param {AuthIn} authIn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authCreate(authIn: AuthIn, options?: any): AxiosPromise<AuthIn> {
            return localVarFp.authCreate(authIn, options).then((request) => request(axios, baseUrl));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * 
     * @param {AuthIn} authIn 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authCreate(authIn: AuthIn, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authCreate(authIn, options).then((request) => request(this.axios, this.baseUrl));
    }
}



/**
 * DepartmentsApi - axios parameter creator
 * @export
 */
export const DepartmentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        departmentsList: async (limit?: number, offset?: number, search?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/departments/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DepartmentsApi - functional programming interface
 * @export
 */
export const DepartmentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DepartmentsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async departmentsList(limit?: number, offset?: number, search?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, baseUrl?: string) => AxiosPromise<PaginatedDepartmentReadList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.departmentsList(limit, offset, search, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerbaseUrl = operationServerMap['DepartmentsApi.departmentsList']?.[localVarOperationServerIndex]?.url;
            return (axios, baseUrl) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerbaseUrl || baseUrl);
        },
    }
};

/**
 * DepartmentsApi - factory interface
 * @export
 */
export const DepartmentsApiFactory = function (configuration?: Configuration, baseUrl?: string, axios?: AxiosInstance) {
    const localVarFp = DepartmentsApiFp(configuration)
    return {
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        departmentsList(limit?: number, offset?: number, search?: string, options?: any): AxiosPromise<PaginatedDepartmentReadList> {
            return localVarFp.departmentsList(limit, offset, search, options).then((request) => request(axios, baseUrl));
        },
    };
};

/**
 * DepartmentsApi - object-oriented interface
 * @export
 * @class DepartmentsApi
 * @extends {BaseAPI}
 */
export class DepartmentsApi extends BaseAPI {
    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {string} [search] A search term.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DepartmentsApi
     */
    public departmentsList(limit?: number, offset?: number, search?: string, options?: RawAxiosRequestConfig) {
        return DepartmentsApiFp(this.configuration).departmentsList(limit, offset, search, options).then((request) => request(this.axios, this.baseUrl));
    }
}



/**
 * DivisionsApi - axios parameter creator
 * @export
 */
export const DivisionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [search] A search term.
         * @param {string} [role] User role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        divisionsList: async (limit?: number, offset?: number, search?: string, role?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/divisions/?roles=${encodeURIComponent(role ?? '')}`;
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            setBasicAuthToObject(localVarRequestOptions, configuration);

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            // Добавляем параметр role в запрос
            if (role !== undefined) {
                localVarQueryParameter['role'] = role;
            }

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * DivisionsApi - functional programming interface
 * @export
 */
export const DivisionsApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = DivisionsApiAxiosParamCreator(configuration);
    return {
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [search] A search term.
         * @param {string} [role] User role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async divisionsList(limit?: number, offset?: number, search?: string, role?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, baseUrl?: string) => AxiosPromise<PaginatedDivisionReadList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.divisionsList(limit, offset, search, role, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerbaseUrl = operationServerMap['DivisionsApi.divisionsList']?.[localVarOperationServerIndex]?.url;
            return (axios, baseUrl) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerbaseUrl || baseUrl);
        },
    };
};

/**
 * DivisionsApi - factory interface
 * @export
 */
export const DivisionsApiFactory = function (configuration?: Configuration, baseUrl?: string, axios?: AxiosInstance) {
    const localVarFp = DivisionsApiFp(configuration);
    return {
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [search] A search term.
         * @param {string} [role] User role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        divisionsList(limit?: number, offset?: number, search?: string, role?: string, options?: any): AxiosPromise<PaginatedDivisionReadList> {
            return localVarFp.divisionsList(limit, offset, search, role, options).then((request) => request(axios, baseUrl));
        },
    };
};

/**
 * DivisionsApi - object-oriented interface
 * @export
 * @class DivisionsApi
 * @extends {BaseAPI}
 */
export class DivisionsApi extends BaseAPI {
    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {string} [search] A search term.
     * @param {string} [role] User role.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DivisionsApi
     */
    public divisionsList(limit?: number, offset?: number, search?: string, role?: string, options?: RawAxiosRequestConfig) {
        return DivisionsApiFp(this.configuration).divisionsList(limit, offset, search, role, options).then((request) => request(this.axios, this.baseUrl));
    }
}



// /**
//  * RequestsApi - axios parameter creator
//  * @export
//  */
// export const RequestsApiAxiosParamCreator = function (configuration?: Configuration) {
//     return {
//         /**
//          * 
//          * @param {*} [options] Override http request option.
//          * @throws {RequiredError}
//          */
//         requestsBusyRetrieve: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
//             const localVarPath = `/api/requests/busy/`;
//             // use dummy base URL string because the URL constructor only accepts absolute URLs.
//             const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
//             let baseOptions;
//             if (configuration) {
//                 baseOptions = configuration.baseOptions;
//             }

//             const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
//             const localVarHeaderParameter = {} as any;
//             const localVarQueryParameter = {} as any;

//             // authentication basicAuth required
//             // http basic authentication required
//             setBasicAuthToObject(localVarRequestOptions, configuration)

//             // authentication cookieAuth required


    
//             setSearchParams(localVarUrlObj, localVarQueryParameter);
//             let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
//             localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

//             return {
//                 url: toPathString(localVarUrlObj),
//                 options: localVarRequestOptions,
//             };
//         },
//         /**
//          * 
//          * @param {RequestCreate} requestCreate 
//          * @param {*} [options] Override http request option.
//          * @throws {RequiredError}
//          */
//         requestsCreate: async (requestCreate: RequestCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
//             // verify required parameter 'requestCreate' is not null or undefined
//             assertParamExists('requestsCreate', 'requestCreate', requestCreate)
//             const localVarPath = `/api/requests/`;
//             // use dummy base URL string because the URL constructor only accepts absolute URLs.
//             const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
//             let baseOptions;
//             if (configuration) {
//                 baseOptions = configuration.baseOptions;
//             }

//             const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
//             const localVarHeaderParameter = {} as any;
//             const localVarQueryParameter = {} as any;

//             // authentication basicAuth required
//             // http basic authentication required
//             setBasicAuthToObject(localVarRequestOptions, configuration)

//             // authentication cookieAuth required


    
//             localVarHeaderParameter['Content-Type'] = 'application/json';

//             setSearchParams(localVarUrlObj, localVarQueryParameter);
//             let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
//             localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
//             localVarRequestOptions.data = serializeDataIfNeeded(requestCreate, localVarRequestOptions, configuration)

//             return {
//                 url: toPathString(localVarUrlObj),
//                 options: localVarRequestOptions,
//             };
//         },
//     }
// };

// /**
//  * RequestsApi - functional programming interface
//  * @export
//  */
// export const RequestsApiFp = function(configuration?: Configuration) {
//     const localVarAxiosParamCreator = RequestsApiAxiosParamCreator(configuration)
//     return {
//         /**
//          * 
//          * @param {*} [options] Override http request option.
//          * @throws {RequiredError}
//          */
//         async requestsBusyRetrieve(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, baseUrl?: string) => AxiosPromise<RequestCreate>> {
//             const localVarAxiosArgs = await localVarAxiosParamCreator.requestsBusyRetrieve(options);
//             const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
//             const localVarOperationServerbaseUrl = operationServerMap['RequestsApi.requestsBusyRetrieve']?.[localVarOperationServerIndex]?.url;
//             return (axios, baseUrl) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerbaseUrl || baseUrl);
//         },
//         /**
//          * 
//          * @param {RequestCreate} requestCreate 
//          * @param {*} [options] Override http request option.
//          * @throws {RequiredError}
//          */
//         async requestsCreate(requestCreate: RequestCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, baseUrl?: string) => AxiosPromise<RequestCreate>> {
//             const localVarAxiosArgs = await localVarAxiosParamCreator.requestsCreate(requestCreate, options);
//             const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
//             const localVarOperationServerbaseUrl = operationServerMap['RequestsApi.requestsCreate']?.[localVarOperationServerIndex]?.url;
//             return (axios, baseUrl) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerbaseUrl || baseUrl);
//         },
//     }
// };

// /**
//  * RequestsApi - factory interface
//  * @export
//  */
// export const RequestsApiFactory = function (configuration?: Configuration, baseUrl?: string, axios?: AxiosInstance) {
//     const localVarFp = RequestsApiFp(configuration)
//     return {
//         /**
//          * 
//          * @param {*} [options] Override http request option.
//          * @throws {RequiredError}
//          */
//         requestsBusyRetrieve(options?: any): AxiosPromise<RequestCreate> {
//             return localVarFp.requestsBusyRetrieve(options).then((request) => request(axios, baseUrl));
//         },
//         /**
//          * 
//          * @param {RequestCreate} requestCreate 
//          * @param {*} [options] Override http request option.
//          * @throws {RequiredError}
//          */
//         requestsCreate(requestCreate: RequestCreate, options?: any): AxiosPromise<RequestCreate> {
//             return localVarFp.requestsCreate(requestCreate, options).then((request) => request(axios, baseUrl));
//         },
//     };
// };

// /**
//  * RequestsApi - object-oriented interface
//  * @export
//  * @class RequestsApi
//  * @extends {BaseAPI}
//  */
// export class RequestsApi extends BaseAPI {
//     /**
//      * 
//      * @param {*} [options] Override http request option.
//      * @throws {RequiredError}
//      * @memberof RequestsApi
//      */
//     public requestsBusyRetrieve(options?: RawAxiosRequestConfig) {
//         return RequestsApiFp(this.configuration).requestsBusyRetrieve(options).then((request) => request(this.axios, this.baseUrl));
//     }

//     /**
//      * 
//      * @param {RequestCreate} requestCreate 
//      * @param {*} [options] Override http request option.
//      * @throws {RequiredError}
//      * @memberof RequestsApi
//      */
//     public requestsCreate(requestCreate: RequestCreate, options?: RawAxiosRequestConfig) {
//         return RequestsApiFp(this.configuration).requestsCreate(requestCreate, options).then((request) => request(this.axios, this.baseUrl));
//     }
// }



/**
 * SchemaApi - axios parameter creator
 * @export
 */
export const SchemaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * OpenApi3 schema for this API. Format can be selected via content negotiation.  - YAML: application/vnd.oai.openapi - JSON: application/vnd.oai.openapi+json
         * @param {SchemaRetrieveFormatEnum} [format] 
         * @param {SchemaRetrieveLangEnum} [lang] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schemaRetrieve: async (format?: SchemaRetrieveFormatEnum, lang?: SchemaRetrieveLangEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/schema/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            if (lang !== undefined) {
                localVarQueryParameter['lang'] = lang;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SchemaApi - functional programming interface
 * @export
 */
export const SchemaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SchemaApiAxiosParamCreator(configuration)
    return {
        /**
         * OpenApi3 schema for this API. Format can be selected via content negotiation.  - YAML: application/vnd.oai.openapi - JSON: application/vnd.oai.openapi+json
         * @param {SchemaRetrieveFormatEnum} [format] 
         * @param {SchemaRetrieveLangEnum} [lang] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async schemaRetrieve(format?: SchemaRetrieveFormatEnum, lang?: SchemaRetrieveLangEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, baseUrl?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.schemaRetrieve(format, lang, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerbaseUrl = operationServerMap['SchemaApi.schemaRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, baseUrl) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerbaseUrl || baseUrl);
        },
    }
};

/**
 * SchemaApi - factory interface
 * @export
 */
export const SchemaApiFactory = function (configuration?: Configuration, baseUrl?: string, axios?: AxiosInstance) {
    const localVarFp = SchemaApiFp(configuration)
    return {
        /**
         * OpenApi3 schema for this API. Format can be selected via content negotiation.  - YAML: application/vnd.oai.openapi - JSON: application/vnd.oai.openapi+json
         * @param {SchemaRetrieveFormatEnum} [format] 
         * @param {SchemaRetrieveLangEnum} [lang] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schemaRetrieve(format?: SchemaRetrieveFormatEnum, lang?: SchemaRetrieveLangEnum, options?: any): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.schemaRetrieve(format, lang, options).then((request) => request(axios, baseUrl));
        },
    };
};

/**
 * SchemaApi - object-oriented interface
 * @export
 * @class SchemaApi
 * @extends {BaseAPI}
 */
export class SchemaApi extends BaseAPI {
    /**
     * OpenApi3 schema for this API. Format can be selected via content negotiation.  - YAML: application/vnd.oai.openapi - JSON: application/vnd.oai.openapi+json
     * @param {SchemaRetrieveFormatEnum} [format] 
     * @param {SchemaRetrieveLangEnum} [lang] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchemaApi
     */
    public schemaRetrieve(format?: SchemaRetrieveFormatEnum, lang?: SchemaRetrieveLangEnum, options?: RawAxiosRequestConfig) {
        return SchemaApiFp(this.configuration).schemaRetrieve(format, lang, options).then((request) => request(this.axios, this.baseUrl));
    }
}

/**
 * @export
 */
export const SchemaRetrieveFormatEnum = {
    Json: 'json',
    Yaml: 'yaml'
} as const;
export type SchemaRetrieveFormatEnum = typeof SchemaRetrieveFormatEnum[keyof typeof SchemaRetrieveFormatEnum];
/**
 * @export
 */
export const SchemaRetrieveLangEnum = {
    Af: 'af',
    Ar: 'ar',
    ArDz: 'ar-dz',
    Ast: 'ast',
    Az: 'az',
    Be: 'be',
    Bg: 'bg',
    Bn: 'bn',
    Br: 'br',
    Bs: 'bs',
    Ca: 'ca',
    Ckb: 'ckb',
    Cs: 'cs',
    Cy: 'cy',
    Da: 'da',
    De: 'de',
    Dsb: 'dsb',
    El: 'el',
    En: 'en',
    EnAu: 'en-au',
    EnGb: 'en-gb',
    Eo: 'eo',
    Es: 'es',
    EsAr: 'es-ar',
    EsCo: 'es-co',
    EsMx: 'es-mx',
    EsNi: 'es-ni',
    EsVe: 'es-ve',
    Et: 'et',
    Eu: 'eu',
    Fa: 'fa',
    Fi: 'fi',
    Fr: 'fr',
    Fy: 'fy',
    Ga: 'ga',
    Gd: 'gd',
    Gl: 'gl',
    He: 'he',
    Hi: 'hi',
    Hr: 'hr',
    Hsb: 'hsb',
    Hu: 'hu',
    Hy: 'hy',
    Ia: 'ia',
    Id: 'id',
    Ig: 'ig',
    Io: 'io',
    Is: 'is',
    It: 'it',
    Ja: 'ja',
    Ka: 'ka',
    Kab: 'kab',
    Kk: 'kk',
    Km: 'km',
    Kn: 'kn',
    Ko: 'ko',
    Ky: 'ky',
    Lb: 'lb',
    Lt: 'lt',
    Lv: 'lv',
    Mk: 'mk',
    Ml: 'ml',
    Mn: 'mn',
    Mr: 'mr',
    Ms: 'ms',
    My: 'my',
    Nb: 'nb',
    Ne: 'ne',
    Nl: 'nl',
    Nn: 'nn',
    Os: 'os',
    Pa: 'pa',
    Pl: 'pl',
    Pt: 'pt',
    PtBr: 'pt-br',
    Ro: 'ro',
    Ru: 'ru',
    Sk: 'sk',
    Sl: 'sl',
    Sq: 'sq',
    Sr: 'sr',
    SrLatn: 'sr-latn',
    Sv: 'sv',
    Sw: 'sw',
    Ta: 'ta',
    Te: 'te',
    Tg: 'tg',
    Th: 'th',
    Tk: 'tk',
    Tr: 'tr',
    Tt: 'tt',
    Udm: 'udm',
    Uk: 'uk',
    Ur: 'ur',
    Uz: 'uz',
    Vi: 'vi',
    ZhHans: 'zh-hans',
    ZhHant: 'zh-hant'
} as const;
export type SchemaRetrieveLangEnum = typeof SchemaRetrieveLangEnum[keyof typeof SchemaRetrieveLangEnum];


/**
 * TypesOfRequestsApi - axios parameter creator
 * @export
 */
export const TypesOfRequestsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [search] A search term.
         * @param {string} [role] User role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        typesOfRequestsList: async (limit?: number, offset?: number, search?: string, role?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/types-of-requests/?roles=${encodeURIComponent(role ?? '')}`;
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // Add basic auth if needed
            setBasicAuthToObject(localVarRequestOptions, configuration);

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * TypesOfRequestsApi - functional programming interface
 * @export
 */
export const TypesOfRequestsApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = TypesOfRequestsApiAxiosParamCreator(configuration);
    return {
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [search] A search term.
         * @param {string} [role] User role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async typesOfRequestsList(limit?: number, offset?: number, search?: string, role?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, baseUrl?: string) => AxiosPromise<PaginatedTypeOfRequestReadList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.typesOfRequestsList(limit, offset, search, role, options);
            return (axios, baseUrl) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, baseUrl);
        },
    };
};

/**
 * TypesOfRequestsApi - factory interface
 * @export
 */
export const TypesOfRequestsApiFactory = function (configuration?: Configuration, baseUrl?: string, axios?: AxiosInstance) {
    const localVarFp = TypesOfRequestsApiFp(configuration);
    return {
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [search] A search term.
         * @param {string} [role] User role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        typesOfRequestsList(limit?: number, offset?: number, search?: string, role?: string, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedTypeOfRequestReadList> {
            return localVarFp.typesOfRequestsList(limit, offset, search, role, options).then((request) => request(axios, baseUrl));
        },
    };
};

/**
 * TypesOfRequestsApi - object-oriented interface
 * @export
 * @class TypesOfRequestsApi
 * @extends {BaseAPI}
 */
export class TypesOfRequestsApi extends BaseAPI {
    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {string} [search] A search term.
     * @param {string} [role] User role.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TypesOfRequestsApi
     */
    public typesOfRequestsList(limit?: number, offset?: number, search?: string, role?: string, options?: RawAxiosRequestConfig) {
        return TypesOfRequestsApiFp(this.configuration).typesOfRequestsList(limit, offset, search, role, options).then((request) => request(this.axios, this.baseUrl));
    }
}



/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeRetrieve: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/users/me/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersMeRetrieve(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, baseUrl?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersMeRetrieve(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerbaseUrl = operationServerMap['UsersApi.usersMeRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, baseUrl) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerbaseUrl || baseUrl);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, baseUrl?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeRetrieve(options?: any): AxiosPromise<void> {
            return localVarFp.usersMeRetrieve(options).then((request) => request(axios, baseUrl));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersMeRetrieve(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersMeRetrieve(options).then((request) => request(this.axios, this.baseUrl));
    }
}



